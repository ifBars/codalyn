/**
 * Base Agent class for MDAP (Multi-Dimensional Agent Protocol)
 */

import type { Backend } from '../contracts/protocols';
import type { GenerateResponse } from '../contracts/models';
import { createRequest } from '../contracts/models';
import { nanoid } from 'nanoid';
import { z } from 'zod';
import type { Artifact } from './artifacts';

export const AgentConfigSchema = z.object({
  id: z.string().default(() => nanoid()),
  name: z.string().optional(),
  role: z.string().optional(),
  systemPrompt: z.string().optional(),
  backend: z.custom<Backend>(),
  temperature: z.number().min(0).max(2).default(0.7),
  maxTokens: z.number().int().positive().default(4096),
  maxIterations: z.number().int().positive().optional().default(10),
  metadata: z.record(z.unknown()).default({}),
  tools: z.any().optional(), // ToolSet instance
});

export type AgentConfig = z.infer<typeof AgentConfigSchema>;

export interface AgentTask {
  id: string;
  prompt: string;
  context?: Record<string, unknown>;
  parentTaskId?: string;
  metadata?: Record<string, unknown>;
  /** Previous agent outputs (context accumulation) */
  previousOutputs?: string[];
  /** Existing artifacts from previous agents */
  existingArtifacts?: Artifact[];
  /** Master plan from orchestrator (Phase 0.2) */
  masterPlan?: {
    objective: string;
    strategy: string;
    tasks: Array<{
      id: string;
      agentRole: string;
      description: string;
    }>;
  };
  /** Progress callback for real-time updates */
  onProgress?: (update: AgentProgressUpdate) => void;
}

export interface AgentProgressUpdate {
  taskId: string;
  agentId: string;
  iteration: number;
  maxIterations: number;
  currentToolCall?: {
    name: string;
    args: any;
    startedAt: number;
  };
  completedToolCalls?: Array<{
    name: string;
    args: any;
    result?: any;
    error?: string;
    duration: number;
    success: boolean;
  }>;
  status: 'thinking' | 'executing_tool' | 'completed' | 'failed';
  message?: string;
}

export interface AgentResult {
  taskId: string;
  agentId: string;
  output: string;
  response: GenerateResponse;
  /** Artifacts generated by this agent */
  artifacts?: Artifact[];
  metadata?: Record<string, unknown>;
}

export class Agent {
  public readonly id: string;
  public readonly name?: string;
  public readonly role?: string;
  protected config: AgentConfig;
  protected backend: Backend;
  protected tools?: any; // ToolSet instance
  protected conversationHistory: Array<{ role: string; content: string }> = [];

  constructor(config: AgentConfig) {
    this.config = AgentConfigSchema.parse(config);
    this.id = this.config.id;
    this.name = this.config.name;
    this.role = this.config.role;
    this.backend = this.config.backend;
    this.tools = this.config.tools;
  }

  /**
   * Execute a task with agentic tool call looping (Think -> Act -> Observe)
   */
  async execute(task: AgentTask): Promise<AgentResult> {
    console.log(`[MDAP Agent ${this.id}] Starting execution for task ${task.id}`);

    // Build enhanced prompt with context and artifacts
    let enhancedPrompt = task.prompt;

    // Add previous agent outputs (context accumulation)
    if (task.previousOutputs && task.previousOutputs.length > 0) {
      const contextSection = `\n\n## Context from Previous Agents\n\n${task.previousOutputs.map((output, i) => `**Agent ${i + 1} Output:**\n${output}`).join('\n\n---\n\n')}`;
      enhancedPrompt += contextSection;
    }

    // Add existing artifacts information
    if (task.existingArtifacts && task.existingArtifacts.length > 0) {
      const artifactsSection = `\n\n## Existing Artifacts\n\nThe following files have been created by previous agents:\n\n${task.existingArtifacts.map(a => `- **${a.path}** (${a.type}, v${a.version}) - ${a.metadata.description || 'No description'}`).join('\n')}`;
      enhancedPrompt += artifactsSection;
    }

    // Add master plan overview (Phase 0.2)
    if (task.masterPlan) {
      const planSection = `\n\n## MASTER PLAN - Your Role in the Overall Strategy

**Project Goal:** ${task.masterPlan.objective}
**Overall Strategy:** ${task.masterPlan.strategy}

**Complete Task Breakdown:**
${task.masterPlan.tasks.map((t, i) =>
  `${i + 1}. [${t.agentRole}] ${t.description}${task.id === t.id ? ' ← YOU ARE HERE' : ''}`
).join('\n')}

⚠️ **CRITICAL:** Follow this plan. Do NOT deviate or add features not in the plan. Your work must align with the overall strategy and enable the agents that come after you.`;
      enhancedPrompt += planSection;
    }

    // Build the system prompt
    const systemPrompt = this.config.systemPrompt
      ? this.config.systemPrompt
      : this.role
      ? `You are a ${this.role} agent.`
      : undefined;

    // Get tool definitions if tools are available
    const toolDefinitions = this.tools?.getDefinitions ? this.tools.getDefinitions() : [];
    const hasTools = toolDefinitions.length > 0;
    console.log(`[MDAP Agent ${this.id}] Has ${toolDefinitions.length} tools available`);

    // Add initial user message to conversation history
    this.conversationHistory.push({ role: 'user', content: enhancedPrompt });

    let iteration = 0;
    const maxIterations = this.config.maxIterations || 10;
    let finalResponse: GenerateResponse | null = null;
    let accumulatedOutput = '';
    const completedToolCalls: Array<{
      name: string;
      args: any;
      result?: any;
      error?: string;
      duration: number;
      success: boolean;
    }> = [];

    // Emit initial progress update
    task.onProgress?.({
      taskId: task.id,
      agentId: this.id,
      iteration: 0,
      maxIterations,
      status: 'thinking',
      message: 'Starting execution...',
    });

    // Agentic loop: Think -> Act -> Observe
    while (iteration < maxIterations) {
      iteration++;
      console.log(`[MDAP Agent ${this.id}] Iteration ${iteration}/${maxIterations}`);

      // Emit progress update for new iteration
      task.onProgress?.({
        taskId: task.id,
        agentId: this.id,
        iteration,
        maxIterations,
        completedToolCalls: completedToolCalls.length > 0 ? [...completedToolCalls] : undefined,
        status: 'thinking',
        message: `Iteration ${iteration}/${maxIterations}: Thinking...`,
      });

      // Create request with current conversation history
      const request = createRequest({
        prompt: '', // Prompt is already in history
        systemPrompt,
        history: this.conversationHistory,
        parameters: {
          temperature: this.config.temperature,
          maxTokens: this.config.maxTokens,
        },
        metadata: {
          agentId: this.id,
          agentName: this.name,
          agentRole: this.role,
          taskId: task.id,
          parentTaskId: task.parentTaskId,
          iteration,
          ...task.metadata,
        },
        tools: hasTools ? toolDefinitions : [],
      });

      // THINK: Generate response from backend
      console.log(`[MDAP Agent ${this.id}] Calling backend...`);
      const response = await this.backend.generate(request, { routedTo: this.id });
      finalResponse = response;

      console.log(`[MDAP Agent ${this.id}] Response received:`, {
        outputText: response.outputText.substring(0, 100) + '...',
        finishReason: response.finishReason,
        hasToolCalls: !!response.toolCalls?.length,
        toolCallCount: response.toolCalls?.length || 0,
      });

      // Accumulate output text
      if (response.outputText) {
        accumulatedOutput += (accumulatedOutput ? '\n\n' : '') + response.outputText;
      }

      // Check for tool calls
      if (!response.toolCalls || response.toolCalls.length === 0) {
        // For code-reviewer, enforce minimum iteration and file read requirements
        const isCodeReviewer = this.id === 'code-reviewer';
        const minIterations = 3;
        const minFileReads = 2;
        const fileReadCount = completedToolCalls.filter(tc => tc.name === 'read_file' && tc.success).length;
        
        if (isCodeReviewer && (iteration < minIterations || fileReadCount < minFileReads)) {
          console.log(`[MDAP Agent ${this.id}] Stopping too early (iteration ${iteration}, ${fileReadCount} files read). Requiring minimum ${minIterations} iterations or ${minFileReads} file reads.`);
          
          // Add assistant message with reminder
          this.conversationHistory.push({
            role: 'assistant',
            content: response.outputText,
          });
          
          // Inject reminder prompt to continue reviewing
          const reminderPrompt = `You are stopping too early. A thorough code review requires:
- At least ${minIterations} iterations of examination
- Reading at least ${minFileReads} key files from the codebase
- Currently: ${iteration} iteration(s), ${fileReadCount} file(s) read

Please continue your review by:
1. Using list_directory to explore more of the project structure
2. Using read_file to examine additional source files (you need at least ${minFileReads - fileReadCount} more)
3. Using find_in_files to search for specific patterns or issues
4. Providing a comprehensive review after thoroughly examining the codebase

Continue using tools to complete a thorough code review.`;
          
          this.conversationHistory.push({
            role: 'user',
            content: reminderPrompt,
          });
          
          // Continue to next iteration instead of breaking
          continue;
        }
        
        console.log(`[MDAP Agent ${this.id}] No tool calls - execution complete`);

        // Add final assistant message to history
        this.conversationHistory.push({
          role: 'assistant',
          content: response.outputText,
        });

        // Emit completion progress
        task.onProgress?.({
          taskId: task.id,
          agentId: this.id,
          iteration,
          maxIterations,
          completedToolCalls: completedToolCalls.length > 0 ? [...completedToolCalls] : undefined,
          status: 'completed',
          message: 'Execution completed',
        });

        break;
      }

      // ACT: Execute tool calls
      console.log(`[MDAP Agent ${this.id}] Executing ${response.toolCalls.length} tool call(s)...`);

      if (!this.tools) {
        console.warn(`[MDAP Agent ${this.id}] Tool calls requested but no ToolSet configured`);
        // Add assistant message and break
        this.conversationHistory.push({
          role: 'assistant',
          content: response.outputText,
        });
        break;
      }

      const toolResults: Array<{
        toolCallId?: string;
        name: string;
        result: any;
        error?: string;
        success: boolean;
      }> = [];

      for (const toolCall of response.toolCalls) {
        console.log(`[MDAP Agent ${this.id}] Executing tool: ${toolCall.name}`);

        // Parse arguments if they're a string
        const args = typeof toolCall.arguments === 'string'
          ? JSON.parse(toolCall.arguments)
          : toolCall.arguments;

        // Emit progress update for tool call start
        const toolCallStartTime = Date.now();
        task.onProgress?.({
          taskId: task.id,
          agentId: this.id,
          iteration,
          maxIterations,
          currentToolCall: {
            name: toolCall.name,
            args,
            startedAt: toolCallStartTime,
          },
          completedToolCalls: completedToolCalls.length > 0 ? [...completedToolCalls] : undefined,
          status: 'executing_tool',
          message: `Executing ${toolCall.name}...`,
        });

        try {
          // Execute tool using ToolSet
          const result = await this.tools.execute({
            id: toolCall.id,
            name: toolCall.name,
            args,
          });

          const toolDuration = Date.now() - toolCallStartTime;
          const toolCallResult = {
            toolCallId: toolCall.id,
            name: toolCall.name,
            result: result.result,
            error: result.error,
            success: result.success,
          };

          toolResults.push(toolCallResult);

          // Track completed tool call
          completedToolCalls.push({
            name: toolCall.name,
            args,
            result: result.result,
            error: result.error,
            duration: toolDuration,
            success: result.success,
          });

          // Limit completed tool calls history to last 20 to avoid memory issues
          if (completedToolCalls.length > 20) {
            completedToolCalls.shift();
          }

          console.log(`[MDAP Agent ${this.id}] Tool ${toolCall.name} executed:`, {
            success: result.success,
            error: result.error,
          });

          // Emit progress update for tool call completion
          task.onProgress?.({
            taskId: task.id,
            agentId: this.id,
            iteration,
            maxIterations,
            completedToolCalls: [...completedToolCalls],
            status: 'executing_tool',
            message: `${toolCall.name} completed`,
          });
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          const toolDuration = Date.now() - toolCallStartTime;
          console.error(`[MDAP Agent ${this.id}] Tool ${toolCall.name} failed:`, errorMessage);

          const toolCallResult = {
            toolCallId: toolCall.id,
            name: toolCall.name,
            result: null,
            error: errorMessage,
            success: false,
          };

          toolResults.push(toolCallResult);

          // Track failed tool call
          completedToolCalls.push({
            name: toolCall.name,
            args,
            error: errorMessage,
            duration: toolDuration,
            success: false,
          });

          // Limit completed tool calls history
          if (completedToolCalls.length > 20) {
            completedToolCalls.shift();
          }

          // Emit progress update for failed tool call
          task.onProgress?.({
            taskId: task.id,
            agentId: this.id,
            iteration,
            maxIterations,
            completedToolCalls: [...completedToolCalls],
            status: 'executing_tool',
            message: `${toolCall.name} failed: ${errorMessage}`,
          });
        }
      }

      // OBSERVE: Add assistant message with tool calls to history
      this.conversationHistory.push({
        role: 'assistant',
        content: response.outputText,
        toolCalls: response.toolCalls.map(tc => ({
          id: tc.id,
          name: tc.name,
          arguments: typeof tc.arguments === 'string' ? tc.arguments : JSON.stringify(tc.arguments),
        })),
      } as any);

      // Add tool results to history
      this.conversationHistory.push({
        role: 'tool',
        toolResults: toolResults.map(tr => ({
          toolCallId: tr.toolCallId,
          name: tr.name,
          content: tr.success
            ? (typeof tr.result === 'string' ? tr.result : JSON.stringify(tr.result))
            : `Error: ${tr.error}`,
        })),
      } as any);

      console.log(`[MDAP Agent ${this.id}] Tool results added to conversation history`);

      // Emit progress update after tool execution completes
      task.onProgress?.({
        taskId: task.id,
        agentId: this.id,
        iteration,
        maxIterations,
        completedToolCalls: [...completedToolCalls],
        status: 'thinking',
        message: `Iteration ${iteration}/${maxIterations} completed, continuing...`,
      });

      // Continue to next iteration
    }

    if (iteration >= maxIterations) {
      console.warn(`[MDAP Agent ${this.id}] Max iterations (${maxIterations}) reached`);
      // Emit final progress update
      task.onProgress?.({
        taskId: task.id,
        agentId: this.id,
        iteration,
        maxIterations,
        completedToolCalls: completedToolCalls.length > 0 ? [...completedToolCalls] : undefined,
        status: 'completed',
        message: 'Max iterations reached',
      });
    }

    console.log(`[MDAP Agent ${this.id}] Execution complete after ${iteration} iteration(s)`);

    // Return result (artifacts will be added by subclasses or orchestrator)
    return {
      taskId: task.id,
      agentId: this.id,
      output: accumulatedOutput || (finalResponse?.outputText || ''),
      response: finalResponse!,
      artifacts: [],
      metadata: {
        role: this.role,
        name: this.name,
        iterations: iteration,
        ...task.metadata,
      },
    };
  }

  /**
   * Clear conversation history
   */
  clearHistory(): void {
    this.conversationHistory = [];
  }

  /**
   * Get conversation history
   */
  getHistory(): Array<{ role: string; content: string }> {
    return [...this.conversationHistory];
  }

  /**
   * Add to conversation history manually
   */
  addToHistory(role: string, content: string): void {
    this.conversationHistory.push({ role, content });
  }

  /**
   * Get agent info
   */
  getInfo(): {
    id: string;
    name?: string;
    role?: string;
    historyLength: number;
  } {
    return {
      id: this.id,
      name: this.name,
      role: this.role,
      historyLength: this.conversationHistory.length,
    };
  }
}

/**
 * Create an agent
 */
export function createAgent(config: AgentConfig): Agent {
  return new Agent(config);
}
