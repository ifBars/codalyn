# MDAP Artifacts System

## Overview

The MDAP Artifacts system provides a structured way to track files, plans, and outputs generated during multi-agent execution. It follows the **Aurelius MDAP pattern** where agents collaborate by passing context and artifacts forward.

## Key Concepts

### 1. Artifact Types

```typescript
type ArtifactType =
  | 'plan'           // Markdown planning documents
  | 'code'           // Code files (ts, tsx, js, jsx, etc.)
  | 'markdown'       // General markdown documentation
  | 'json'           // JSON data files
  | 'image'          // Images (base64 encoded)
  | 'text'           // Plain text files
  | 'other';         // Other file types
```

### 2. Artifact Structure

```typescript
interface Artifact {
  id: string;                    // Unique identifier
  filename: string;              // Filename with extension
  path: string;                  // Relative path from project root
  content: string;               // File content (base64 for images)
  mimeType: string;              // MIME type
  type: ArtifactType;            // Semantic type
  metadata: ArtifactMetadata;    // Metadata (agent, timestamps, etc.)
  version: number;               // Version number (incremented on updates)
}
```

### 3. Artifact Metadata

```typescript
interface ArtifactMetadata {
  agentId?: string;              // Agent that created this
  agentRole?: string;            // Agent role
  createdAt?: Date;              // Creation timestamp
  updatedAt?: Date;              // Last update timestamp
  taskId?: string;               // Task that generated this
  description?: string;          // Human-readable description
  tags?: string[];               // Categorization tags
  custom?: Record<string, unknown>;
}
```

## MDAP Workflow with Artifacts

### Planning Phase

When a task is executed with a main agent, the orchestrator creates a structured plan:

```typescript
const result = await orchestrator.execute({
  prompt: 'Build a todo list component',
  workflow: 'sequential',
});

// Result includes:
result.plan               // Decomposed plan structure
result.planArtifact      // Markdown plan file
result.artifacts         // All artifacts from execution
```

The plan artifact is automatically stored at:
```
plans/YYYY-MM-DD-plan-{taskId}.md
```

### Execution Phase

During execution, each agent:
1. Receives all artifacts from previous agents
2. Receives context (outputs) from previous agents
3. Can create/update artifacts
4. Passes everything forward to next agent

```typescript
// Agent receives:
task.previousOutputs      // Array of previous agent outputs
task.existingArtifacts   // Array of current artifacts

// Agent returns:
result.artifacts         // New/updated artifacts
```

### Artifact Registry

The orchestrator maintains an `ArtifactRegistry` that:
- Tracks all artifacts by ID and path
- Handles versioning (updates increment version number)
- Supports querying by type, agent, path, etc.

```typescript
// Get artifacts
registry.getAll()                    // All artifacts
registry.getPlans()                  // Only plan artifacts
registry.getByType('code')           // By type
registry.getByAgent('code-generator') // By agent
registry.getByPath('src/App.tsx')    // By path
```

## Studio Integration

### Storage Structure

Artifacts should be stored in the project with this structure:

```
project/
├── plans/                      # MDAP execution plans
│   ├── 2025-01-28-plan-abc123.md
│   ├── 2025-01-28-plan-def456.md
│   └── ...
├── src/                        # Generated code
│   ├── components/
│   │   └── TodoList.tsx       # From code-generator agent
│   ├── tests/
│   │   └── TodoList.test.tsx  # From tester agent
│   └── ...
└── docs/                       # Generated documentation
    └── architecture.md        # From architect agent
```

### Plan File Format

Plan artifacts use this markdown format:

```markdown
# MDAP Execution Plan

**Generated:** 2025-01-28T12:00:00.000Z

## Objective

Build a todo list component

## Strategy

Create a React component with TypeScript, add tests, and ensure quality through review.

## Task Breakdown

### 1. Code Generator

- **Task ID:** `task-1`
- **Description:** Create TodoList component with TypeScript
- **Complexity:** Medium

### 2. Tester

- **Task ID:** `task-2`
- **Description:** Write comprehensive tests for TodoList
- **Complexity:** Low

### 3. Quality Assurance

- **Task ID:** `task-3`
- **Description:** Review all outputs and identify issues
- **Complexity:** Low

### 4. Finalizer

- **Task ID:** `task-4`
- **Description:** Integrate components and fix issues
- **Complexity:** Medium

---

*This plan was generated by the MDAP orchestrator*
```

### Viewing Plans in Studio

The studio should provide a **Plans** section in the builder UI:

```
Builder UI
├── Code Editor        (existing)
├── Preview            (existing)
├── Chat               (existing)
└── Plans              (NEW)
    ├── List of execution plans (chronological)
    ├── Plan viewer (markdown renderer)
    └── Execution status (if active)
```

### Implementation in Studio

```typescript
// In your builder component
import type { Artifact, OrchestratorResult } from '@codalyn/accuralai';

// After MDAP execution
const result: OrchestratorResult = await orchestrator.execute({
  prompt: userPrompt,
  workflow: 'sequential',
});

// Save plan artifact to project storage
if (result.planArtifact) {
  await saveArtifactToProject(projectId, result.planArtifact);
}

// Save all other artifacts
for (const artifact of result.artifacts) {
  if (artifact.type === 'code') {
    await saveArtifactToProject(projectId, artifact);
  }
}

// Display in Plans UI
<PlansViewer
  plans={result.artifacts.filter(a => a.type === 'plan')}
  currentPlan={result.planArtifact}
/>
```

## Helper Functions

### Creating Artifacts

```typescript
import { ArtifactHelpers } from '@codalyn/accuralai';

// Create a plan artifact
const planArtifact = ArtifactHelpers.createPlan({
  filename: 'my-plan',
  content: markdownContent,
  description: 'Execution plan for feature X',
  agentId: 'planner',
  agentRole: 'planner',
  taskId: 'task-123',
});

// Create a code artifact
const codeArtifact = ArtifactHelpers.createCode({
  filename: 'TodoList.tsx',
  path: 'src/components/TodoList.tsx',
  content: codeContent,
  description: 'TodoList React component',
  agentId: 'code-generator',
  agentRole: 'code-generation',
});

// Format plan as markdown
const markdown = ArtifactHelpers.formatPlanMarkdown({
  title: 'Feature Implementation Plan',
  objective: 'Build X feature',
  strategy: 'Approach description',
  tasks: [...],
  timestamp: new Date(),
});
```

### Using the Registry

```typescript
import { createArtifactRegistry } from '@codalyn/accuralai';

const registry = createArtifactRegistry();

// Add artifacts
const artifact1 = registry.addOrUpdate({
  filename: 'App.tsx',
  content: '...',
});

// Update existing (versions it)
const artifact2 = registry.addOrUpdate({
  filename: 'App.tsx',  // Same filename
  content: '...',        // New content
});
console.log(artifact2.version); // 2

// Query
const plans = registry.getPlans();
const codeFiles = registry.getByType('code');
const qaOutputs = registry.getByAgent('qa-agent');
```

## Aurelius Pattern Implementation

The system now implements the key Aurelius MDAP patterns:

### 1. ✅ Planning Phase
- Main agent decomposes objectives into structured plans
- Generates markdown plan artifact automatically
- Includes strategy, tasks, and metadata

### 2. ✅ Context Accumulation
- Each agent receives outputs from all previous agents
- Enables iterative refinement and context awareness
- Prevents agents from working in isolation

### 3. ✅ Artifact Management
- All generated files are tracked as artifacts
- Artifacts can be updated/versioned by subsequent agents
- Complete audit trail of what was created when and by whom

### 4. ✅ Mandatory QA Sequence
- `qualityAssurance` agent reviews all outputs
- `finalizer` agent integrates and fixes issues
- Ensures quality control before completion

### 5. ✅ Studio Integration
- Plans stored in `plans/` directory
- Viewable in separate Plans section
- Timestamped and organized chronologically

## API Reference

### Types

```typescript
import type {
  Artifact,
  ArtifactType,
  ArtifactMetadata,
  ArtifactRegistry,
} from '@codalyn/accuralai';
```

### Registry Methods

```typescript
class ArtifactRegistry {
  addOrUpdate(artifact: Partial<Artifact>): Artifact;
  get(id: string): Artifact | undefined;
  getByPath(path: string): Artifact | undefined;
  getAll(): Artifact[];
  getByType(type: ArtifactType): Artifact[];
  getPlans(): Artifact[];
  getByAgent(agentId: string): Artifact[];
  delete(id: string): boolean;
  clear(): void;
  count(): number;
}
```

### Helpers

```typescript
const ArtifactHelpers = {
  createPlan(config): Partial<Artifact>;
  createCode(config): Partial<Artifact>;
  formatPlanMarkdown(plan): string;
};
```

## Best Practices

### 1. Always Use the Registry
Don't track artifacts manually. Use the orchestrator's built-in registry.

### 2. Descriptive Paths
Use meaningful paths that reflect the project structure:
```typescript
// Good
path: 'src/components/auth/LoginForm.tsx'

// Bad
path: 'file1.tsx'
```

### 3. Include Metadata
Always provide descriptions and tags for better organization:
```typescript
metadata: {
  description: 'Login form with email validation',
  tags: ['auth', 'form', 'validation'],
}
```

### 4. Version Awareness
Check artifact versions when making updates:
```typescript
const existing = registry.getByPath('src/App.tsx');
if (existing && existing.version > 1) {
  // This file has been modified before
}
```

### 5. Plan Storage
Store plans in a dedicated directory for easy viewing:
```
plans/YYYY-MM-DD-plan-{taskId}.md
```

## Next Steps for Studio

1. **UI Component**: Create `PlansViewer` component to display plan artifacts
2. **Storage Integration**: Implement `saveArtifactToProject()` to persist artifacts
3. **Plans Section**: Add navigation item to builder UI for plans
4. **Real-time Updates**: Show plan generation and execution progress
5. **Artifact Browser**: Optional UI to browse all generated artifacts

## Example: Complete Flow

```typescript
// 1. Create orchestrator with plan generation
const orchestrator = createBuilderMdapOrchestrator({
  modelName: 'google:gemini-2.5-flash',
  googleApiKey: process.env.GOOGLE_API_KEY,
});

// 2. Execute task
const result = await orchestrator.execute({
  prompt: 'Build a user authentication system',
  workflow: 'sequential',
});

// 3. Access plan
console.log('Plan:', result.plan);
console.log('Plan Artifact:', result.planArtifact);

// 4. Access all artifacts
result.artifacts.forEach(artifact => {
  console.log(`${artifact.path} (v${artifact.version}) by ${artifact.metadata.agentRole}`);
});

// 5. Get specific artifact types
const plans = result.artifacts.filter(a => a.type === 'plan');
const code = result.artifacts.filter(a => a.type === 'code');

// 6. Save to project (studio implementation)
await saveToProject(projectId, result.artifacts);
```

---

**Implementation Status**: ✅ Complete

All MDAP artifact features are now implemented and ready for studio integration.
