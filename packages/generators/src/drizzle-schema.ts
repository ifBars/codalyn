import { EntitySpec, EntityField, FieldType } from "@codalyn/dsl";
import { pascalCase, camelCase } from "@codalyn/shared";

export function generateDrizzleSchema(entity: EntitySpec): string {
  const tableName = camelCase(entity.name) + "Table";
  const columns = entity.fields.map((field) => generateColumn(field)).join("\n  ");

  return `import { sqliteTable, text, integer, real, blob } from "drizzle-orm/sqlite-core";
import { relations } from "drizzle-orm";

export const ${tableName} = sqliteTable("${camelCase(entity.name)}", {
${columns}
});

export const ${camelCase(entity.name)}Relations = relations(${tableName}, ({ one, many }) => ({}));
`;
}

function generateColumn(field: EntityField): string {
  const fieldName = camelCase(field.name);
  const columnType = mapFieldTypeToDrizzle(field.type);
  const nullable = field.required ? "" : ".notNull()";
  const defaultValue = field.defaultValue !== undefined ? `.default(${JSON.stringify(field.defaultValue)})` : "";

  return `  ${fieldName}: ${columnType}${nullable}${defaultValue},`;
}

function mapFieldTypeToDrizzle(type: FieldType): string {
  switch (type) {
    case "string":
    case "email":
    case "url":
    case "text":
      return "text()";
    case "number":
      return "integer()";
    case "boolean":
      return "integer()"; // SQLite uses integer for boolean
    case "date":
      return "text()"; // Store as ISO string
    case "json":
      return "blob()";
    default:
      return "text()";
  }
}

export function generateDrizzleSchemaIndex(entity: EntitySpec): string {
  if (entity.indexes.length === 0) {
    return "";
  }

  const imports = entity.indexes.length > 0 ? 'import { index } from "drizzle-orm/sqlite-core";\n' : "";

  return `${imports}${entity.indexes.map((idx) => `export const ${camelCase(entity.name)}${pascalCase(idx)}Index = index("${idx}").on(${camelCase(entity.name)}Table.${camelCase(idx)});`).join("\n")}`;
}

export function generateMigrations(entity: EntitySpec): string {
  // This would typically be generated by drizzle-kit
  return `// Migration for ${entity.name}
// Run: npm run db:generate
// Run: npm run db:migrate
`;
}

export function generateSeedData(entity: EntitySpec, count: number = 10): string {
  const entityName = pascalCase(entity.name);
  const tableName = camelCase(entity.name) + "Table";

  const seedItems = Array.from({ length: count }, (_, i) => {
    const item: Record<string, unknown> = {};
    entity.fields.forEach((field) => {
      item[field.name] = generateSeedValue(field, i);
    });
    return item;
  });

  return `import { db } from "@/lib/db";
import { ${tableName} } from "@/lib/db/schema";

export async function seed${entityName}() {
  const seeds = ${JSON.stringify(seedItems, null, 2)};

  for (const seed of seeds) {
    await db.insert(${tableName}).values(seed);
  }
}
`;
}

function generateSeedValue(field: EntityField, index: number): unknown {
  if (field.defaultValue !== undefined) {
    return field.defaultValue;
  }

  switch (field.type) {
    case "string":
    case "text":
      return `${field.name} ${index + 1}`;
    case "email":
      return `test${index + 1}@example.com`;
    case "url":
      return `https://example.com/${index + 1}`;
    case "number":
      return index + 1;
    case "boolean":
      return index % 2 === 0;
    case "date":
      return new Date(2024, 0, index + 1).toISOString();
    case "json":
      return {};
    default:
      return null;
  }
}

