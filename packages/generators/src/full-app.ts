import { AppSpec } from "@codalyn/dsl";
import { generateReactComponent } from "./react-component";
import { generateNextPage } from "./next-page";
import { generateCRUDPages } from "./crud";
import { generateDrizzleSchema } from "./drizzle-schema";

export interface GeneratedProject {
  files: Record<string, string>;
  packageJson: string;
  tsconfigJson: string;
  readme: string;
}

export function generateFullApp(spec: AppSpec): GeneratedProject {
  const files: Record<string, string> = {};

  // Generate components
  spec.components.forEach((component) => {
    files[`components/${component.name}.tsx`] = generateReactComponent(component);
  });

  // Generate pages
  spec.pages.forEach((page) => {
    const componentNames = page.components.map((id) => {
      const comp = spec.components.find((c) => c.id === id);
      return comp ? comp.name : null;
    }).filter(Boolean) as string[];

    files[`app${page.route}/page.tsx`] = generateNextPage(page, componentNames);
  });

  // Generate CRUD operations
  spec.crudOperations.forEach((crud) => {
    const entity = spec.entities.find((e) => e.id === crud.entityId);
    if (entity) {
      const crudFiles = generateCRUDPages(entity, crud);
      Object.assign(files, crudFiles);
    }
  });

  // Generate database schemas
  spec.entities.forEach((entity) => {
    files[`lib/db/schema/${entity.name}.ts`] = generateDrizzleSchema(entity);
  });

  // Generate package.json
  files["package.json"] = generatePackageJson(spec);

  // Generate tsconfig.json
  files["tsconfig.json"] = generateTSConfig();

  // Generate next.config.js
  files["next.config.js"] = generateNextConfig();

  // Generate tailwind.config.js
  files["tailwind.config.js"] = generateTailwindConfig();

  // Generate README
  files["README.md"] = generateREADME(spec);

  // Generate environment schema
  if (Object.keys(spec.environment).length > 0) {
    files["lib/env.ts"] = generateEnvSchema(spec);
  }

  return {
    files,
    packageJson: files["package.json"],
    tsconfigJson: files["tsconfig.json"],
    readme: files["README.md"],
  };
}

function generatePackageJson(spec: AppSpec): string {
  return JSON.stringify(
    {
      name: spec.name.toLowerCase().replace(/\s+/g, "-"),
      version: spec.version,
      private: true,
      scripts: {
        dev: "next dev",
        build: "next build",
        start: "next start",
        lint: "next lint",
        "db:generate": "drizzle-kit generate",
        "db:migrate": "drizzle-kit migrate",
        "db:studio": "drizzle-kit studio",
      },
      dependencies: {
        react: "^18.2.0",
        "react-dom": "^18.2.0",
        next: "^15.0.0",
        "drizzle-orm": "^0.29.0",
        "@types/node": "^20.10.0",
        "@types/react": "^18.2.0",
        "@types/react-dom": "^18.2.0",
        typescript: "^5.3.3",
        zod: "^3.22.4",
        tailwindcss: "^3.4.0",
        "drizzle-kit": "^0.20.0",
        "better-sqlite3": "^9.2.0",
        "@types/better-sqlite3": "^7.6.0",
      },
      devDependencies: {
        eslint: "^8.55.0",
        "eslint-config-next": "^15.0.0",
        autoprefixer: "^10.4.16",
        postcss: "^8.4.32",
      },
    },
    null,
    2
  );
}

function generateTSConfig(): string {
  return JSON.stringify(
    {
      compilerOptions: {
        target: "ES2022",
        lib: ["dom", "dom.iterable", "esnext"],
        allowJs: true,
        skipLibCheck: true,
        strict: true,
        forceConsistentCasingInFileNames: true,
        noEmit: true,
        esModuleInterop: true,
        module: "esnext",
        moduleResolution: "bundler",
        resolveJsonModule: true,
        isolatedModules: true,
        jsx: "preserve",
        incremental: true,
        plugins: [{ name: "next" }],
        paths: {
          "@/*": ["./*"],
        },
      },
      include: ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
      exclude: ["node_modules"],
    },
    null,
    2
  );
}

function generateNextConfig(): string {
  return `/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
};

module.exports = nextConfig;
`;
}

function generateTailwindConfig(): string {
  return `/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
`;
}

function generateREADME(spec: AppSpec): string {
  return `# ${spec.name}

${spec.description || "Generated by Codalyn"}

## Getting Started

\`\`\`bash
npm install
npm run dev
\`\`\`

## Database

\`\`\`bash
npm run db:generate  # Generate migrations
npm run db:migrate   # Run migrations
npm run db:studio    # Open Drizzle Studio
\`\`\`

## Deployment

See deployment instructions in the [Next.js documentation](https://nextjs.org/docs/deployment).
`;
}

function generateEnvSchema(spec: AppSpec): string {
  const envVars = Object.entries(spec.environment)
    .map(([key, config]) => {
      const zodType = config.type === "string" ? "z.string()" : config.type === "number" ? "z.number()" : "z.boolean()";
      const required = config.required ? "" : ".optional()";
      const defaultValue = config.defaultValue !== undefined ? `.default(${JSON.stringify(config.defaultValue)})` : "";
      return `  ${key}: ${zodType}${required}${defaultValue},`;
    })
    .join("\n");

  return `import { z } from "zod";

const envSchema = z.object({
${envVars}
});

export const env = envSchema.parse(process.env);
`;
}

